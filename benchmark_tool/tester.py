import logging
import tempfile
import subprocess
import os
import re
from typing import Tuple, Optional

class CodeTester:
    """
    A class that tests Python code generated by CodeGenerator using Pytest, 
    without requiring a known function name. The first 'def function_name(' 
    it finds will be tested.
    """

    def __init__(self):
        # Setup logging if needed
        self.logger = logging.getLogger(__name__)
        if not self.logger.handlers:
            logging.basicConfig(level=logging.INFO)

    def test_code(self, code_str: str, task: str) -> Tuple[bool, str]:
        """
        Tests the generated Python code by:
            1) Writing it to a temporary file (generated_code.py).
            2) Parsing out the first function name (if any).
            3) Creating a minimal test_ file that:
               - Imports the module
               - Calls the function (if found)
            4) Running pytest as a subprocess, capturing console output.

        Args:
            code_str (str): The Python code to test.

        Returns:
            (success, output):
                success (bool)  : True if tests passed, False otherwise
                output  (str)   : The captured stdout/stderr from the pytest run
        """
        # Ensure the code is non-empty
        if not code_str.strip():
            raise ValueError("Cannot test empty code string")

        # Try to find the *first* function name defined in the code
        function_name = self._find_function_name(code_str)
        if not function_name:
            return False, "No function definition found in generated code"

        # Build test code with the actual function name
        test_code = self._build_test_code(task, function_name)
        
        # Create a temporary directory to store the generated code and test
        with tempfile.TemporaryDirectory() as tmpdir:
            # 1) Write the generated code to a file
            code_file_path = os.path.join(tmpdir, "generated_code.py")
            with open(code_file_path, "w", encoding="utf-8") as f:
                f.write(code_str)

            # 2) Write the test file
            test_file_path = os.path.join(tmpdir, "test_generated_code.py")
            with open(test_file_path, "w", encoding="utf-8") as f:
                f.write(test_code)

            # 3) Run pytest as a subprocess
            cmd = [
                "pytest",
                "--maxfail=1",
                "--disable-warnings",
                "--tb=short",
                "-v",
                "--no-header",
                test_file_path
            ]

            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                cwd=tmpdir,
                text=True
            )
            out, _ = process.communicate()

            success = (process.returncode == 0)

            # Log results
            if success:
                self.logger.info("Pytest: All tests passed successfully.")
            else:
                self.logger.warning("Pytest: Some tests failed. Output:\n%s", out)

            return success, out

    def _find_function_name(self, code_str: str) -> Optional[str]:
        """
        Parses the code string to find the first function definition,
        i.e., a line matching 'def <name>('.

        Returns:
            The name of the first function, or None if none found.
        """
        # Regex to match a Python function definition:
        # ^\s*def\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(
        # Explanation:
        # - ^\s*: Start of line with optional whitespace
        # - def\s+: 'def' followed by 1+ spaces
        # - ([a-zA-Z_][a-zA-Z0-9_]*): Capture group for valid Python identifier
        # - \s*\(: Optional whitespace followed by '('
        pattern = r'^\s*def\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\('
        match = re.search(pattern, code_str, flags=re.MULTILINE)
        if match:
            return match.group(1)
        return None

    def _build_test_code(self, task: str, function_name: str) -> str:
        """
        Creates task-specific test file with appropriate assert tests.
        
        Args:
            task (str): Name of the task to test (e.g., 'fft', 'inverse_fft')
            function_name (str): The actual name of the function found in generated code
        """
        test_code = [
            "import pytest",
            "import numpy as np",
            "from scipy import signal",
            "import generated_code"
        ]

        if task == "fft":
            test_code.append(f"""
def test_fft_implementation():
    # Generate test signal
    t = np.linspace(0, 1, 1000)
    test_signal = np.sin(2 * np.pi * 10 * t)
    test_signal = np.asarray(test_signal, dtype=float)
    
    # Get the function from generated code using dynamic name
    result = getattr(generated_code, "{function_name}")(test_signal)
    reference = np.fft.fft(test_signal)
    
    # Test assertions
    assert len(result) == len(test_signal), "FFT length should match input length"
    assert np.allclose(np.abs(result), np.abs(reference), rtol=1e-10), "FFT magnitude differs from numpy.fft"
    assert isinstance(result, np.ndarray), "Result should be numpy array"
""")

        elif task == "inverse_fft":
            test_code.append(f"""
def test_inverse_fft_implementation():
    # Generate test spectrum
    N = 1000
    spectrum = np.zeros(N, dtype=complex)
    spectrum[10] = 1  # Single frequency component
    
    # Test inverse FFT
    result = getattr(generated_code, "{function_name}")(spectrum)
    reference = np.fft.ifft(spectrum)
    
    assert len(result) == N, "IFFT length should match input length"
    assert np.allclose(result, reference, rtol=1e-10), "IFFT output differs from numpy.ifft"
""")

        elif task == "resampling":
            test_code.append(f"""
def test_resampling_implementation():
    # Generate test signal
    original_length = 1000
    new_length = 500
    t = np.linspace(0, 1, original_length)
    input_signal = np.sin(2 * np.pi * 10 * t)  # Renamed from 'signal' to 'input_signal'
    
    # Test resampling
    result = getattr(generated_code, "{function_name}")(input_signal, new_length)
    reference = signal.resample(input_signal, new_length)  # Now unambiguous
    
    assert len(result) == new_length, f"Resampled length should be new_length"
    assert np.allclose(result, reference, rtol=1e-10), "Resampling differs from scipy.signal"
""")

        elif task == "convolution":
            test_code.append(f"""
def test_convolution_implementation():
    # Test signals
    signal = np.array([1, 2, 3, 4, 5])
    kernel = np.array([0.5, 0.5])
    
    # Test convolution
    result = getattr(generated_code, "{function_name}")(signal, kernel)
    reference = np.convolve(signal, kernel, mode='full')
    
    assert len(result) == len(reference), "Convolution length incorrect"
    assert np.allclose(result, reference, rtol=1e-10), "Convolution differs from numpy.convolve"
    assert isinstance(result, np.ndarray), "Result should be numpy array"
""")
            
        elif task == "low_pass_filter":
            test_code.append(f"""
def test_low_pass_filter_implementation():
    # Test parameters
    fs = 500 
    t = np.linspace(0, 1, fs, endpoint=False)
    
    # Create test signal with low (5 Hz) and high (50 Hz) frequency components
    low_freq = np.sin(2 * np.pi * 5 * t)
    high_freq = 0.5 * np.sin(2 * np.pi * 50 * t)
    input_signal = low_freq + high_freq
    
    # Get result from generated function
    result = getattr(generated_code, "{function_name}")(
        input_signal=input_signal,
        fs=fs,
        cutoff_freq=10,
        order=4
    )
    
    # Create reference using scipy implementation
    nyq = 0.5 * fs
    normalized_cutoff = 10 / nyq
    b, a = signal.butter(4, normalized_cutoff, btype='low')
    reference = signal.lfilter(b, a, input_signal)
    
    # Test assertions
    assert len(result) == len(input_signal), "Output length must match input length"
    assert np.allclose(result, reference, rtol=1e-10), "Filter output differs from scipy.signal reference"
""")

        else:
            # Default test for unknown tasks
            test_code.append("""
def test_basic_implementation():
    assert True, "No specific tests defined for this task"
""")

        return "\n".join(test_code)
