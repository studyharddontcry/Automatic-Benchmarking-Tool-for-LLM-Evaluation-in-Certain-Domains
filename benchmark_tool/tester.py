import logging
import tempfile
import subprocess
import os
import re
from typing import Tuple, Optional

class CodeTester:
    """
    A class that tests Python code generated by CodeGenerator using Pytest, 
    without requiring a known function name. The first 'def function_name(' 
    it finds will be tested.
    """

    def __init__(self):
        # Setup logging if needed
        self.logger = logging.getLogger(__name__)
        if not self.logger.handlers:
            logging.basicConfig(level=logging.INFO)

    def test_code(self, code_str: str, task: str) -> Tuple[bool, str]:
        """
        Tests the generated Python code by:
            1) Writing it to a temporary file (generated_code.py).
            2) Parsing out the first function name (if any).
            3) Creating a minimal test_ file that:
               - Imports the module
               - Calls the function (if found)
            4) Running pytest as a subprocess, capturing console output.

        Args:
            code_str (str): The Python code to test.

        Returns:
            (success, output):
                success (bool)  : True if tests passed, False otherwise
                output  (str)   : The captured stdout/stderr from the pytest run
        """
        # Ensure the code is non-empty
        if not code_str.strip():
            raise ValueError("Cannot test empty code string")

        # Try to find the *first* function name defined in the code
        function_name = self._find_function_name(code_str)

        # Create a temporary directory to store the generated code and test
        with tempfile.TemporaryDirectory() as tmpdir:
            # 1) Write the generated code to a file
            code_file_path = os.path.join(tmpdir, "generated_code.py")
            with open(code_file_path, "w", encoding="utf-8") as f:
                f.write(code_str)

            # 2) Build a minimal test file
            test_code = self._build_test_code(task)

            # 3) Write the test file
            test_file_path = os.path.join(tmpdir, "test_generated_code.py")
            with open(test_file_path, "w", encoding="utf-8") as f:
                f.write(test_code)

            # 4) Run pytest as a subprocess
            cmd = [
                "pytest",
                "--maxfail=1",
                "--disable-warnings",
                "--tb=short",
                test_file_path
            ]

            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                cwd=tmpdir,
                text=True
            )
            out, _ = process.communicate()

            success = (process.returncode == 0)

            # Log results
            if success:
                self.logger.info("Pytest: All tests passed successfully.")
            else:
                self.logger.warning("Pytest: Some tests failed.")

            return success, out

    def _find_function_name(self, code_str: str) -> Optional[str]:
        """
        Parses the code string to find the first function definition,
        i.e., a line matching 'def <name>('.

        Returns:
            The name of the first function, or None if none found.
        """
        # Regex to match a Python function definition:
        # ^\s*def\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(
        # Explanation:
        # - ^\s*: Start of line with optional whitespace
        # - def\s+: 'def' followed by 1+ spaces
        # - ([a-zA-Z_][a-zA-Z0-9_]*): Capture group for valid Python identifier
        # - \s*\(: Optional whitespace followed by '('
        pattern = r'^\s*def\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\('
        match = re.search(pattern, code_str, flags=re.MULTILINE)
        if match:
            return match.group(1)
        return None

    def _build_test_code(self, task: str) -> str:
        """
        Creates task-specific test file with appropriate assert tests.
        
        Args:
            task (str): Name of the task to test (e.g., 'fft', 'inverse_fft')
        """
        # Base imports needed for all tests
        test_code = [
            "import pytest",
            "import numpy as np",
            "from scipy import signal",
            "import generated_code"
        ]

        if task == "fft":
            test_code.append("""
def test_fft_implementation():
    # Generate test signal
    t = np.linspace(0, 1, 1000)
    test_signal = np.sin(2 * np.pi * 10 * t)  # 10 Hz sinusoid
    
    # Get the function from generated code
    result = generated_code.fft_function(test_signal)
    reference = np.fft.fft(test_signal)
    
    # Test assertions
    assert len(result) == len(test_signal), "FFT length should match input length"
    assert np.allclose(np.abs(result), np.abs(reference), rtol=1e-10), "FFT magnitude differs from numpy.fft"
    assert isinstance(result, np.ndarray), "Result should be numpy array"
""")

        elif task == "inverse_fft":
            test_code.append("""
def test_inverse_fft_implementation():
    # Generate test spectrum
    N = 1000
    spectrum = np.zeros(N, dtype=complex)
    spectrum[10] = 1  # Single frequency component
    
    # Test inverse FFT
    result = generated_code.inverse_fft_function(spectrum)
    reference = np.fft.ifft(spectrum)
    
    assert len(result) == N, "IFFT length should match input length"
    assert np.allclose(result, reference, rtol=1e-10), "IFFT output differs from numpy.ifft"
    assert np.all(np.abs(np.imag(result)) < 1e-10), "IFFT should return real signal"
""")

        elif task == "resampling":
            test_code.append("""
def test_resampling_implementation():
    # Generate test signal
    original_length = 1000
    new_length = 500
    t = np.linspace(0, 1, original_length)
    signal = np.sin(2 * np.pi * 10 * t)
    
    # Test resampling
    result = generated_code.resample_function(signal, new_length)
    reference = signal.resample(signal, new_length)
    
    assert len(result) == new_length, f"Resampled length should be {new_length}"
    assert np.allclose(result, reference, rtol=1e-10), "Resampling differs from scipy.signal"
    assert isinstance(result, np.ndarray), "Result should be numpy array"
""")

        elif task == "convolution":
            test_code.append("""
def test_convolution_implementation():
    # Test signals
    signal = np.array([1, 2, 3, 4, 5])
    kernel = np.array([0.5, 0.5])
    
    # Test convolution
    result = generated_code.convolve_function(signal, kernel)
    reference = np.convolve(signal, kernel, mode='full')
    
    assert len(result) == len(reference), "Convolution length incorrect"
    assert np.allclose(result, reference, rtol=1e-10), "Convolution differs from numpy.convolve"
    assert isinstance(result, np.ndarray), "Result should be numpy array"
""")

        else:
            # Default test for unknown tasks
            test_code.append("""
def test_basic_implementation():
    assert True, "No specific tests defined for this task"
""")

        return "\n".join(test_code)
